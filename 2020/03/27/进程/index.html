
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>操作系统——进程 - 久诗的小窝</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="久诗,"> 
    <meta name="description" content="本人第一次写的blog，有许多不足，欢迎大佬提意见,进程进程控制
所谓进程控制，就是系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换，从而达到多进程高效率并发执行和协调，实现资源共享的目的
原语：把系统下执行的某些具有特定功,"> 
    <meta name="author" content="久诗"> 
    <link rel="alternative" href="atom.xml" title="久诗的小窝" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">久诗的小窝</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">操作系统——进程</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">操作系统——进程</h1>
        <div class="stuff">
            <span>三月 27, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h5 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h5><ul>
<li>所谓进程控制，就是系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换，从而达到多进程高效率并发执行和协调，实现资源共享的目的</li>
<li>原语：把系统下执行的某些具有特定功能的程序段称为原语，原语是不能被中断的。用于进程控制的原语有创建原语、撤销原语、阻塞原语、唤醒原语等等</li>
</ul>
<h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>资源共享所引起的制约</p>
<p>尽管进程具有独立性和异步性等并发特征。但是，有限的资源导致了进程之间的资源竞争和共享，如果不加以控制，会导致恶劣的后果。</p>
<ol>
<li><p>临界区</p>
<ul>
<li>把系统中不允许也同时多个进程访问的资源成为临界资源，而在进程中访问临界资源的那段程序称为临界区。</li>
<li>或者，把不允许多个并发进程交叉执行的一段程序称为临界区。</li>
<li>注意：临界区不是资源，而是程序段</li>
</ul>
</li>
<li><p>间接制</p>
</li>
<li><p>间接制约</p>
<p>以公用数据或临界资源划分临界区的集合称为类，用以下标准形式来描述临界区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when &lt;类名&gt;</span><br><span class="line">do</span><br><span class="line">	&lt;临界区&gt;</span><br><span class="line">od</span><br></pre></td></tr></table></figure>

<p>对于由共享共有资源引起的制约，称为间接制约。</p>
<p>对于每一类来说，系统应有分配和释放公有资源的管理办法，以制约并发进程，这就是互斥。</p>
</li>
<li><p>互斥</p>
<p>互斥的定义：</p>
<p>把不允许两个以上的共享某共有资源的并发进程同时进入临界区称为互斥。</p>
<p>互斥的原则：</p>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ol>
</li>
<li><p>互斥的加锁实现</p>
<p>当某个进程进入临界区之后，它将锁上临界区，直到它退出临界区为止。并发进程在申请进入临界区时，首先测试该临界区是否上锁。如果该临界区已经被锁住，则该进程要等到该临界区开锁后才有可能进入临界区</p>
<p>设临界区类名为S，锁定位key[S]。加锁后的临界去程序描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock(key[S])</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">unlock(key[S])</span><br></pre></td></tr></table></figure>

<p>这里，key[S]= =1表示可用，key[S]= =0表示不可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unlock实现：</span><br><span class="line">	key[S]&lt;-1</span><br><span class="line">lock实现：</span><br><span class="line">	lock(x):begin</span><br><span class="line">		local v</span><br><span class="line">		repeat</span><br><span class="line">			v&lt;-x</span><br><span class="line">		until v&#x3D;1</span><br><span class="line">		x&lt;-0</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>利用TS(Test and Set)指令实现互斥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Procedure TS(var x,y:boolean)</span><br><span class="line">	var temp:boolean;</span><br><span class="line">	begin</span><br><span class="line">		temp :&#x3D; x;</span><br><span class="line">		x :&#x3D; y;</span><br><span class="line">		y :&#x3D; temp;</span><br><span class="line">	end;</span><br><span class="line">	</span><br><span class="line">	Var key:boolean;</span><br><span class="line">	begin</span><br><span class="line">		...</span><br><span class="line">		key :&#x3D; true;</span><br><span class="line">		while key do TS(lock,key);</span><br><span class="line">			临界区操作</span><br><span class="line">		lock :&#x3D; false;</span><br><span class="line">		...</span><br><span class="line">	end;</span><br></pre></td></tr></table></figure>

<p>加锁法貌似比较好的解决了互斥访问临界资源的问题，可是，它也有两个非常突出的缺点：</p>
<ol>
<li>处理及必须不断的测试，造成严重的浪费</li>
<li>不公平现象。“永久饥饿”、</li>
</ol>
<p>因此我们需要一种更好的解决办法。</p>
</li>
<li><p>信号量和P，V原语</p>
<p>信号量：信号量是一种特殊的变量，他的表现形式是一个正式附加一个队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore&#123;</span><br><span class="line">	int value;</span><br><span class="line">	pointer_PCB queue;</span><br><span class="line">&#125;</span><br><span class="line">semaphore s;&#x2F;&#x2F;信号量说明</span><br></pre></td></tr></table></figure>

<ul>
<li>信号量用于管理临界区的公有资源，信号量sem的值是一个整数<ul>
<li>sem大于等于0时代表可供并发进程使用的资源实体数</li>
<li>sem小于0时则表示正在等待使用临界区的进程数。</li>
<li>PS:后面会有更容易理解的说法，此处可以不用强行理解。（具体请跳到PS小节）</li>
</ul>
</li>
</ul>
</li>
<li><p>P原语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore s;</span><br><span class="line">P(s)&#123;</span><br><span class="line">	封锁中断;&#x2F;&#x2F;该原语执行过程中不允许中断</span><br><span class="line">	s.value &#x3D; s.value - 1;</span><br><span class="line">	if (s.value &lt; 0)&#123;</span><br><span class="line">		保护当前进程CPU现场；</span><br><span class="line">		该进程状态置为等待状态；</span><br><span class="line">		将该进程的PCB插入相应的等待队列末尾s.queue;</span><br><span class="line">		转进程调度；</span><br><span class="line">	&#125;</span><br><span class="line">	开中断；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="9">
<li><p>V原语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore s;</span><br><span class="line">V(s)&#123;</span><br><span class="line">	封锁中断;</span><br><span class="line">	s.value &#x3D; s.value+1;</span><br><span class="line">	if (s.value &lt;&#x3D; 0)&#123;</span><br><span class="line">		唤醒相应等待队列s.queue中的一个等待状态；</span><br><span class="line">		改变其状态为就绪态；</span><br><span class="line">		并将其插入就绪队列；</span><br><span class="line">		转进程调度；</span><br><span class="line">	&#125;</span><br><span class="line">	开中断；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="10">
<li><p>用P，V原语实现进程互斥</p>
<p>设sem是用于互斥的信号量，初值为1，表示没有进程进入该临界区，只要把临界区至于P(sem)和V(sem)之间，就可以实现进程间的互斥。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">P(sem)</span><br><span class="line">&lt;S</span><br><span class="line">V(sem)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>相比之下，使用P，V原语使得处理机不再频繁的测试，使处理机解放出来。其次，“永久饥饿”现象得到了解决，当使用完临界资源的进程做了V操作之后，将主动唤醒某一正在等待使用该资源的进程。</p>
</li>
<li><p>经典互斥问题：读者—写者问题（read—write问题）</p>
<p>有两组并发进程：</p>
<p>​    读者（read）和写者（write），共享一组数据区</p>
<p>要求：</p>
<p>​    允许多个读者同时执行read操作</p>
<p>不允许读者、写者同时操作</p>
<p>不允许多个写者同时操作</p>
<ol>
<li><p>第一类：读者优先</p>
<p>如果有读者来：</p>
<ol>
<li>无读者、写者，新读者可以读</li>
<li>有写者等，但有其他读者正在读，则新读者也可以读</li>
<li>有写者写，新读者等</li>
</ol>
<p>如果有写者来：</p>
<ol>
<li><p>无读者、写者，新写者可以写</p>
</li>
<li><p>有读者读，新写者等待</p>
</li>
<li><p>有其他写者写，新写者等待</p>
<p>读者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">	if (count &#x3D; &#x3D; 0)</span><br><span class="line">		P (wMutex);</span><br><span class="line">	count ++;</span><br><span class="line">	</span><br><span class="line">	读数据；</span><br><span class="line">	</span><br><span class="line">	count - -;</span><br><span class="line">	if (count &#x3D; &#x3D;0)</span><br><span class="line">		V (wMutex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">	P(wMutex);</span><br><span class="line">	</span><br><span class="line">	写数据；</span><br><span class="line">	</span><br><span class="line">	V(wMutex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置两个互斥信号量和一个共享变量。</p>
<ol>
<li><p>共享变量为count，初值为0，表示正在读进程的数目；</p>
</li>
<li><p>由于count本身也是个临界资源，所以设置一个互斥信号量rMutex，初值为1，用以实现读进程互斥地访问count；</p>
</li>
<li><p>设置一个写互斥信号量wMutex初值为1，用以实现读与写进程之间的互斥和写与写进程之间的互斥</p>
<p>读者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">	P(rMutex);</span><br><span class="line">	if(count &#x3D; &#x3D;0)</span><br><span class="line">		P(wMutex);</span><br><span class="line">	count ++;</span><br><span class="line">	V(rMutex);</span><br><span class="line">	读数据；</span><br><span class="line">	P(rMutex);</span><br><span class="line">	count - -;</span><br><span class="line">	if(count &#x3D; &#x3D; 0)</span><br><span class="line">		V(wMutex);</span><br><span class="line">	V(rMutex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">	P(wMutex);</span><br><span class="line">	</span><br><span class="line">	写数据；</span><br><span class="line">	</span><br><span class="line">	V(wMutex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>第二类：写者优先</p>
<p>条件：</p>
<ol>
<li><p>多个读者可以同时进行读</p>
</li>
<li><p>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</p>
</li>
<li><p>写者唤醒优先于读者（一旦有写者在等，则后续读者必须等待，唤醒时优先唤醒写者）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reader()&#123;</span><br><span class="line">    	while (true)&#123;</span><br><span class="line">    		P(s);</span><br><span class="line">    		P(rmutex);</span><br><span class="line">    		if (count &#x3D; &#x3D; 0)</span><br><span class="line">    			P(wmutex);</span><br><span class="line">    		count + +;</span><br><span class="line">    		V(rmutex);</span><br><span class="line">    		V(s);</span><br><span class="line">    		读文件;</span><br><span class="line">    		P(rmutex);</span><br><span class="line">    		count - -;</span><br><span class="line">    		if (count &#x3D; &#x3D;0)</span><br><span class="line">    			V(wmutex);</span><br><span class="line">    		V(rmutex);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">writer()&#123;</span><br><span class="line">    	while (true)&#123;</span><br><span class="line">    		P(s);</span><br><span class="line">    		P(wmutex);</span><br><span class="line">    		写文件;</span><br><span class="line">    		V(wmutex);</span><br><span class="line">    		V(s);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><ol>
<li><p>同步的概念</p>
<p>同步与互斥不同，这些并发的程序之间存在着直接制约的关系。</p>
<p>把一组并发进程，因直接制约而相互发送消息进行相互合作。相互等待，使得各进程按一定的速度执行的过程称为进程间的同步。</p>
</li>
<li><p>私用信号量</p>
<p>一般来说，也可以把个进程之间发送的消息作为信号量看待。与进程互斥时不同的是，这里的信号量只与制约进程及被制约进程有关，而不是与整组并发进程有关。因此，该信号量为私用信号量。与之对应，互斥时使用的信号量为共用信号量。</p>
</li>
<li><p>用P、V原语实现同步（单缓冲）</p>
<p>设进程A、B通过缓冲区Buf传递数据。A为发送数据，B为接收进程。A调用deposit（data）,B调用remove（dataa）。条件如下：</p>
<ol>
<li>缓冲区空时，B不能取</li>
<li>缓冲区满时，A不能发送</li>
</ol>
</li>
<li><p>用P、V原语实现同步（多缓冲）</p>
<p>设进程A、B通过缓冲区队列传递数据。A为发送进程，B为接收进程。A调用deposit（data）,B调用remove（data），条件如下：</p>
<ol>
<li>缓冲区队列为空时，B不能取</li>
<li>缓冲区队列满时，A不能发送</li>
<li>缓冲队列按FIFO方式排列</li>
</ol>
</li>
</ol>
<h5 id="总结互斥与同步做题方法"><a href="#总结互斥与同步做题方法" class="headerlink" title="总结互斥与同步做题方法"></a>总结互斥与同步做题方法</h5><ol>
<li>首先分析是什么类型的题：纯互斥、纯同步、同步+加互斥（如果是纯同步的题，直接跳到第六步）</li>
<li>同步+互斥题先做同步。后做互斥</li>
<li>分析存在几个运行主题</li>
<li>站在每个运行主题的角度思考：它需要申请什么资源（条件）、释放什么资源（结果）</li>
<li>分析同步的初值（无其他进程时能运行多少次）</li>
<li>找到临界区（临界资源），完成互斥</li>
</ol>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><ol>
<li><p>生产者 — 消费者问题</p>
<p>如果有一群生产者进程和一群消费者进程同时访问缓冲区队列，该如何解决？这时，同步和互斥问题是我们都要考虑的。</p>
<ol>
<li><p>为互斥设置一个公有信号量Mutex，初值为1</p>
</li>
<li><p>为同步设置两个私有信号量empty，初值为n</p>
<pre><code>full，初值为0</code></pre></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">deposit(data)&#123;</span><br><span class="line">	P(empty);</span><br><span class="line">	P(Mutex);</span><br><span class="line">	Buf(x)&lt;-data;</span><br><span class="line">	V(Mutex);</span><br><span class="line">	V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove(data)&#123;</span><br><span class="line">	P(full);</span><br><span class="line">	P(Mutex);</span><br><span class="line">	data&lt;-Buf(x);</span><br><span class="line">	V(Mutex);</span><br><span class="line">	V(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   或</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">deposit(data)&#123;</span><br><span class="line">	P(Mutex);</span><br><span class="line">	P(empty);</span><br><span class="line">	Buf(x)&lt;-data;</span><br><span class="line">	V(Mutex);</span><br><span class="line">	V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove(data)&#123;</span><br><span class="line">	P(Mutex);</span><br><span class="line">	P(full);</span><br><span class="line">	data&lt;-Buf(x);</span><br><span class="line">	V(Mutex);</span><br><span class="line">	V(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>   注意：</p>
<pre><code>* P、V操作必须同时成对出现，有一个P操作就一定有V操作
* 当为互斥操作时，他们同处于同一进程
* 当为同步操作时，则不再同一进程中出现
* 如果P(S1)和P(S2)两个操作同时在一起，那么P操作的顺序至关重要，一个同步P操作与一个互斥P操作在一起时，同步P操作在互斥P操作前
* 而两个V操作无关紧要</code></pre><ol start="2">
<li><p>哲学家问题</p>
<p>有五个则学家在一个圆桌上，五个人正好围坐满这张桌子，五个哲学家以思考、就餐交替执行的方式进行活动，桌上只有五只筷子，每只筷子在两个哲学家之间。</p>
<p>为每只筷子设置一个信号量，初值都为1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var chop array[0,1,2,3,4] of semaphore;</span><br></pre></td></tr></table></figure>

<p>哲学家i的活动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">	思考：</span><br><span class="line">	p(chop[i]);&#x2F;&#x2F;申请左边的筷子</span><br><span class="line">	p(chop[(i+1)%5]);&#x2F;&#x2F;申请右边的筷子</span><br><span class="line">	进食：</span><br><span class="line">	v(chop[i]);&#x2F;&#x2F;释放左边的筷子</span><br><span class="line">	v(chop[(i+1)]%5);&#x2F;&#x2F;释放右边的筷子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的问题在哪里？？？</p>
<p>如果五个哲学家一起停止思考（哲学家的心态发生了一些变化owo），一起进食，就会导致每一个哲学家都只能拿到一只筷子，从而无法进食，达成死锁成就，（然后为了能够生存下去，他们只能进行惨烈的厮杀，然后？然后就看谁能吃鸡呗٩(๑´0`๑)۶）扯远了扯远了。</p>
<p>接下来我们将对这个做法进行优化。</p>
<p>我们可以给这五位哲学家定一个规矩，一次最多只能有四个人去进食，那么至少能有一个哲学家进食成功（ko no dio da!）或者我们可以规定，</p>
<p>对于奇数号的哲学家，首先取左边的筷子，</p>
<p>对于偶数号的哲学家，首先取右边的筷子，</p>
<p>这样一来也能解决了｡:.ﾟヽ(｡◕‿◕｡)ﾉﾟ.:｡+ﾟ</p>
<p>（此时请点开左上角的音乐播放按钮）</p>
<p>没错，我们所做的思考都不是徒劳的，只要我们不停止思考，前方就会有路（哲学家你在做什么啊哲学家！），只要思考不停下来，我就会在前方等着你们！所以说，不要停下来啊（指思考）【希望の花~】</p>
</li>
<li><p>司机 — 售票员问题</p>
<p>司机活动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	启动车辆</span><br><span class="line">	正常行驶</span><br><span class="line">	到站停车</span><br><span class="line">&#125;while(1)</span><br></pre></td></tr></table></figure>

<p>售票员活动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	关车门</span><br><span class="line">	售票</span><br><span class="line">	开车门</span><br><span class="line">&#125;while(1)</span><br></pre></td></tr></table></figure>

<p>这是一个很常见的同步问题</p>
<p>来来来，上解析代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var s1,s2: semaphore;(initial value 0)</span><br><span class="line">司机活动：</span><br><span class="line">	Repeat</span><br><span class="line">		P(S1)</span><br><span class="line">		启动车辆</span><br><span class="line">		正常行驶</span><br><span class="line">		到站停车</span><br><span class="line">		V(S2)</span><br><span class="line">	Until false</span><br><span class="line">	</span><br><span class="line">售票员活动：</span><br><span class="line">	Repeat</span><br><span class="line">		关车门</span><br><span class="line">		V(S1)</span><br><span class="line">		售票</span><br><span class="line">		P(S2)</span><br><span class="line">		开车门</span><br><span class="line">	Until false</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h5><ul>
<li><p>PV原语的含义</p>
<p>P操作和V操作是不可中断的程序段，称为原语。。信号量sem是一整数，sem大于等于零时代表可供并发进程使用的资源实体数，但sem小于零时则表示正在等待使用临界区的进程数。<br>P原语操作的动作是：</p>
<ol>
<li>sem减1；</li>
<li>若sem减1后仍大于或等于零，则进程继续执行；</li>
<li>若sem减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。</li>
</ol>
<p>V原语操作的动作是：</p>
<ol>
<li>sem加1；</li>
<li>若相加结果大于零，则进程继续执行；</li>
<li>若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后再返回原进程继续执行或转进程调度。</li>
</ol>
<p>PV操作对于每一个进程来说，都只能进行一次，而且必须成对使用。在PV原语执行期间不允许有中断的发生。</p>
</li>
<li><p>具体PV原语对信号量的操作可以分为三种情况：</p>
<ol>
<li><p>把信号量视为一个加锁标志位，实现对一个共享变量的互斥访问。<br>实现过程：</p>
<pre><code>P(mutex); // mutex的初始值为1 访问该共享数据;
V(mutex);
非临界区</code></pre></li>
<li><p>把信号量视为是某种类型的共享资源的剩余个数，实现对一类共享资源的访问。<br>实现过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(resource); &#x2F;&#x2F; resource的初始值为该资源的个数N 使用该资源；</span><br><span class="line">V(resource); 非临界区</span><br></pre></td></tr></table></figure>
</li>
<li><p>把信号量作为进程间的同步工具<br>实现过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">临界区C1；</span><br><span class="line">P(S);</span><br><span class="line">V(S);</span><br><span class="line">临界区C2；</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h5 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h5><p>好了，今天就到这儿，下次我弄一弄管程</p>
<p>PS:补充一下，可能当你多年后再次看到这里的时候你已经忘记文中的梗了（什么嘛，我玩梗还是很屑的嘛），那请麻烦你动动小手自行萌娘百科“不要停下来啊”这个词条，我可不是屑小鬼，有谁会说自己是屑小鬼呢。ε=ε=ε=ε=ε=ε=┌(;￣◇￣)┘</p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="http://link.hhtjim.com/163/1376882360.mp3">
            </audio>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#进程控制"><span class="toc-number">1.0.1.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程互斥"><span class="toc-number">1.0.2.</span> <span class="toc-text">进程互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程同步"><span class="toc-number">1.0.3.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总结互斥与同步做题方法"><span class="toc-number">1.0.4.</span> <span class="toc-text">总结互斥与同步做题方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#例题"><span class="toc-number">1.0.5.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PS"><span class="toc-number">1.0.6.</span> <span class="toc-text">PS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#结束语"><span class="toc-number">1.0.7.</span> <span class="toc-text">结束语</span></a></li></ol></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
